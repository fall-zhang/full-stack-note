> Create by **fall** on 09 May 2023<br/>
> Recently revised in 06 Nov 2025

## docker 命令

### 镜像

镜像（Image）：一个系统的一瞬间进行保存，可以不断地从该点创建分支进行运行（要修改只能创建新的镜像）。

> 如果拉取镜像配置失败，可能需要[配置代理](#配置代理)
>

- `docker images` 查看所有 docker 镜像（等价于 `docker image ls`）
- `docker pull hello-world` 从远程拉取 hello-world 镜像
- `docker rmi hello-world` 删除 hello-world 镜像
- `docker create <image_name>` 创建一个新的镜像
- `docker run <hello-world>` 启动镜像（创建容器）（如果没有，会从网络上拉取 `docker pull`），额外参数如下

```bash
# 以交互模式运行 ubuntu
docker container run -it ubuntu bash

# 多个配置可以分别书写
docker run --name example-name -d --env DB_NAME=gitlabhq_production --env DB_USER=gitlab --env DB_PASS=admin_99565 --env --publish 7022:22 DB_EXTENSION=pg_trgm,btree_gist --volume /srv/docker/gitlab/postgresql:/var/lib/postgresql  example-image:12.22.12
```

- `-i` 以交互模式运行镜像
- `-e` & `--env` 配置环境变量（只推荐在开发环境中使用环境变量配置连接端口
- `-d` & `--detach` 创建一个守护式容器在后台运行（容器创建后自动在后台运行）
- `-t` 创建启动后会进入其命令行。（加入 `-it` 后，会创建立即登录进入，分配一个伪终端）
- `--name` 为创建的容器命名
- `-v` & `-volume` 表示目录映射关系
- `-w` & `--workdir` 容器的工作目录（如果路径不存在，会在容器内创建目录，并且会默认进入该目录）
- `--mount` 设置 volume 映射
- `-p` & `--publish` 表示端口映射（`-p 2022:80` 将容器的 80 端口映射到本地的 2022 端口上）
  - 没有端口映射，你不能通过端口进入应用（Without the port mapping, you wouldn’t be able to access the application from the host.）
- `-network=host` 让容器和主机共享一个网络空间
- `--shm-size` 共享内存设定值
  - 共享内存：允许两个不相关的进程访问同一个逻辑内存，两个正在运行的进程之间共享和传递数据的一种有效方式
- `--hostname` 主机名，当配置域名的时候需要使用

> 拉取后的镜像如何使用，请参考对应镜像的文档，或者在该网站（https://hub-stage.docker.com）进行搜索对应的镜像，查看使用方式

### 容器

一个镜像可以多次运行，产生不同的容器

容器相关命令

```bash
# 查看正在运行的容器
docker ps
docker ps -a # 查看所有容器
# 启动容器
docker start <container-name & id>
# 停止容器
docker stop <container-name & id>
# 强制停止容器
docker kill <container-name & id>
# 重启容器
docker restart <container-name & id>

# 从磁盘中删除容器
docker container rm <container-name & id>
# 在运行的指定容器中执行命令（需要启动容器）
docker exec -it <container-name & id> <command>
# 在运行的指定容器中，打开 shell
docker exec -it <container-name & id> sh
```

### volume

容器内数据的持续存储方式

容器对文件进行的任何操作都将会在移除容器（container）后丢失，Docker 会隔绝 container 所有的操作。volume 能在选定容器和当前文件系统路径进行链接（映射）。

所以我们需要用 volume 将存储的数据（或者开发的内容）映射到操作系统的目录中来，如果没有 volume，修改的内容将会彻底丢失。

主要有两种 volume 类型

- volume mount：存储你的应用数据（docker 决定存储位置，让各个容器之间共享数据）
- bind mount：在本地和容器之间共享一个文件系统

**volume mount**（具名 volume）

- 创建：`docker volume create my-volume`
- 获取 volume 列表：`docker volume ls`
- 删除 volume：`docker volume rm my-volume`
  - 删除没有任何容器使用的 volume：`docker volumn prune -a`


```bash
# 启动镜像，并且将目录绑定到 volume 容器上
docker run -dp 127.0.0.1:3000:3000 --mount type=bind,src=/path/to/data,target=/usr/local/data <image-name>
# 如果想声明 volume，可以更改 type 为 type=volume,src=my-volume,target=/usr/local/data
# src 表示使用的 volume
# target 容器对应的路径
```

**bind mount**（绑定 volume）

```bash
# --mount 去创建 volume
docker run -it --mount "type=bind,src=$pwd,target=/src" ubuntu bash
# 将当前目录和新创建的 ubuntu 容器指定目录进行绑定。 
# 绑定后，如果绑定目录存在内容，会将容器内的目录屏蔽（不会删除或者修改，但是也不能使用），使用本地文件夹代替 mount 文件夹使用
```

> 如果指定的 volume 不存在，docker 默认会创建该 volume 的内容
>
> - volume mount 如果没有内容，添加后默认内容将会是容器中目录内的内容
> - bind mount 绑定后，如果绑定目录存在内容，会**屏蔽容器内的目录**（不会删除或者修改，但是也不能使用），使用本地文件夹代替 mount 的文件夹使用。
>
> bind mount 关联的文件系统，如果在容器内运行，就是调用容器的 api 和功能，如果在本地运行，就是调用本地的功能。推荐应用场景：
>
> - 在本地和容器间共享配置文件
> - 提供源码或者在环境中构建

|                  | Named volumes | Bind mounts |
| ---------------- | ------------- | ----------- |
| 本地存放位置     | Docker 决定   | 自己决定    |
| 覆盖新容器的内容 | 是            | 否          |

### 网络

- 方法一：通过镜像创建容器的时候
- 方法二：向已有的容器添加网络

无论哪个方法，首先先添加网络

```powershell
docker network create todo-app
```

方法一：

创建时链接网络

```powershell
docker run -d `
  --network todo-app --network-alias mysql `
  -v todo-mysql-data:/var/lib/mysql `
  -e MYSQL_ROOT_PASSWORD=secret `
  -e MYSQL_DATABASE=todos `
  mysql:8.0
# 通过 --network todo-app 指定网络
# --network-alias 为网络命名，容器内部搜索网络时，可以通过该别名搜索，并且可以将其它容器的 HOST 配置为该别名
```

方法二：将应用容器挂载到网络上

```bash
docker network connect <network_id or network_name> <container_id or container_name>
```

网络相关命令

```bash
# 列出所有网络
docker network ls
# 创建一个网络
docker network create todo-app
# 创建网络
docker network create --driver <driver-name> <bridge-name>
# 容器连接到网络
docker network connect <network_id or network_name> <container_id or container_name>
# 断开容器和网络的链接
docker network disconnect <network_name_or_id> <container_name_or_id>
# 移除网络
docker network rm <network_id or network_name>

## 使用 host 模式，共享主机的网络
docker run -d --network host mysql:8.0
```

### 日志

系统运行时，命令行输出的内容

```bash
# 获取容器日志 docker
docker container logs <container_id or container_name>
docker logs <container_id or container_name>
# 监控容器日志
docker container logs -f <container_id or container_name>
```

### 镜像和容器的导出

部署 docker 容器会遇到网络问题，比如服务器在内网，不能连接外网的情况，或者网络下载慢，不通畅；我们就可以编译、导出镜像后在内网服务器导入，就可以实现内网部署。

**镜像导出**

```bash
# 镜像的导出
docker save img:latest > img.tar
# 或者
docker save -o img.tar img:latest
# 将镜像打包为 tar 文件
# 导出镜像尽量使用 image:tag 的形式，使用镜像 id 容易出现导入后镜像名出现 <none> 的情况

# 多个镜像同时导出为一个文件
docker save img1:latest img2:latest > img.tar

```

**镜像导入**

```bash
# 将导出的镜像导入
docker load < img.tar
```

**容器导出**

```bash
# 将容器导出为 server.tar 文件
docker export 3e877a80b319 > server.tar
```

**容器导入**

导入后的容器文件会成为一个镜像，我们可以为它指定新的名称，如果存在同名镜像，原有的名称会被剥夺，赋给新的镜像。

```bash
# 将 server.tar 文件导入为镜像
docker import server.tar my-server:latest
```

## 创建镜像

创建镜像时必须要用到 Dockerfile，会使用该 Dockerfile 文件的配置生成二进制的 image 文件。

创建 docker 镜像，大致需要三个步骤

- 创建 Dockerfile 文件
- 编写文件内容
- 使用 `docker build -t getting-started .` 命令

> 最后的 `.` 符号说明可以在当前文件夹内找到 `Dockerfile`

`docker build` 命令的结构 `docker build -t <image_name> <dockerfile>`

- `-t` 是 `-tag` 的缩写，允许镜像指定后面的标签，比如 `redis:6.2`，通常用来区分版本
- `<image_name>` 镜像名称
- `<dockerfile>` dockerfile 文件，指定路径
- `--platform linux/amd64` 可选参数，指定环境为 linux/amd

## 参考文章

| 作者          | 文章名称                                                     |
| ------------- | ------------------------------------------------------------ |
| 爱笑的架构师  | [5分钟带你快速了解Docker和k8s](https://juejin.cn/post/6913568633813729294) |
| wljslmz       | [Docker小白的福音：50条Docker命令清单，干就完了！](https://juejin.cn/post/7127082572399509511) |
| Rain_or_Shine | [Docker 入门教程-阮一峰](https://juejin.cn/post/6844903561432662023) |
| 天行无忌      | [WEB开发人员应该知道 10 个 Docker 命令](https://juejin.cn/post/7188341548692537402) |
| 杨高超        | [通过 docker 搭建自用的 gitlab 服务](https://juejin.cn/post/6844903544496062472) |
| 官方文档      | https://docs.docker.com/get-started/02_our_app/              |
| 佳庆          | [docker-compose讲解与安装](https://juejin.cn/post/7220730324752859195) |
|               |                                                              |



